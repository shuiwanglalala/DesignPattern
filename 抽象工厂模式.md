# 抽象工厂模式

## 抽象工厂模式适合应用场景

+ 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂
+ 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式

## 抽象工厂模式优缺点

-  你可以确保同一工厂生成的产品相互匹配
  - 这是区别工厂模式的点
-  你可以避免客户端和具体产品代码的耦合。
-  *单一职责原则*。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
-  *开闭原则*。 向应用程序中引入新产品变体时， 你无需修改客户端代码

# 工厂模式比较

https://refactoringguru.cn/design-patterns/factory-comparison

## 构建方法

在实际中， 构建方法只是构造函数调用的封装器。 它可能只是一个能更好地表达意图的名称。 此外， 它可以让你的代码独立于构造函数的改动， 甚至还可以包含一些特殊的逻辑， 返回已有对象以而不是创建新对象

## 静态构建方法

**静态构建方法**是被声明为 `static`的构建方法。 换句话说， 你无需创建对象就能在某个类上调用该方法

```
BitmapFactory
```

## 简单工厂模式

**简单工厂**模式 描述了一个类， 它拥有一个包含大量条件语句的构建方法， 可根据方法的参数来选择对何种产品进行初始化并将其返回。

人们通常会将*简单工厂*与普通的*工厂*或其它创建型设计模式混淆。 在绝大多数情况下， 简单工厂是引入[工厂方法](https://refactoringguru.cn/design-patterns/factory-method)或[抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)模式时的一个中间步骤。

简单工厂通常没有子类。 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的*工厂方法*模式了。

## 工厂方法模式

**工厂方法** 是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

## 抽象工厂模式

**抽象工厂** 》 是一种创建型设计模式， 它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。